From da53e03290600c9c34e6806d4ec5d2db9bc3a1a6 Mon Sep 17 00:00:00 2001
From: Frank Sae <Frank.Sae@motor-comm.com>
Date: Sat, 23 Nov 2024 23:38:44 -0800
Subject: [PATCH] net: phy: Add driver for Motorcomm YT8521S Gigabit ethernet
 phy

Add driver for Motorcomm YT8521S Gigabit ethernet phy.

Signed-off-by: Frank Sae <Frank.Sae@motor-comm.com>
---
 drivers/net/phy/motorcomm.c | 90 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 89 insertions(+), 1 deletion(-)

--- a/drivers/net/phy/motorcomm.c
+++ b/drivers/net/phy/motorcomm.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Motorcomm YT8511/YT8531/YT8531S/YT8821 PHY driver.
+ * Motorcomm YT8511/YT8531/YT8531S/YT8821/YT8521S PHY driver.
  *
  * Copyright (C) 2023 StarFive Technology Co., Ltd.
  * Copyright (C) 2024 Motorcomm Electronic Technology Co., Ltd.
@@ -15,6 +15,7 @@
 #define PHY_ID_YT8531				0x4f51e91b
 #define PHY_ID_YT8821				0x4f51ea19
 #define PHY_ID_YT8531S				0x4f51e91a
+#define PHY_ID_YT8521S				0x0000011a
 #define PHY_ID_MASK				GENMASK(31, 0)
 
 /* Extended Register's Address Offset Register */
@@ -35,6 +36,17 @@
 #define YTPHY_DTS_OUTPUT_CLK_25M		25000000
 #define YTPHY_DTS_OUTPUT_CLK_125M		125000000
 
+#define YT8521S_SCR_SYNCE_ENABLE		BIT(5)
+/* 1b0 output 25m clock   *default*
+ * 1b1 output 125m clock
+ */
+#define YT8521S_SCR_CLK_FRE_SEL_125M		BIT(3)
+#define YT8521S_SCR_CLK_SRC_MASK		GENMASK(2, 1)
+#define YT8521S_SCR_CLK_SRC_PLL_125M		0
+#define YT8521S_SCR_CLK_SRC_UTP_RX		1
+#define YT8521S_SCR_CLK_SRC_SDS_RX		2
+#define YT8521S_SCR_CLK_SRC_REF_25M		3
+
 #define YT8511_EXT_CLK_GATE	0x0c
 #define YT8511_EXT_DELAY_DRIVE	0x0d
 #define YT8511_EXT_SLEEP_CTRL	0x27
@@ -1116,6 +1128,71 @@ static int yt8821_startup(struct phy_dev
 	return 0;
 }
 
+static int yt8521s_config(struct phy_device *phydev)
+{
+	struct ytphy_plat_priv *priv = phydev->priv;
+	u16 mask, val;
+	int ret;
+
+	ret = genphy_config_aneg(phydev);
+	if (ret < 0)
+		return ret;
+
+	ytphy_dt_parse(phydev);
+	switch (priv->clk_out_frequency) {
+	case YTPHY_DTS_OUTPUT_CLK_DIS:
+		mask = YT8521S_SCR_SYNCE_ENABLE;
+		val = 0;
+		break;
+	case YTPHY_DTS_OUTPUT_CLK_25M:
+		mask = YT8521S_SCR_SYNCE_ENABLE | YT8521S_SCR_CLK_SRC_MASK |
+			   YT8521S_SCR_CLK_FRE_SEL_125M;
+		val = YT8521S_SCR_SYNCE_ENABLE |
+			  FIELD_PREP(YT8521S_SCR_CLK_SRC_MASK,
+				     YT8521S_SCR_CLK_SRC_REF_25M);
+		break;
+	case YTPHY_DTS_OUTPUT_CLK_125M:
+		mask = YT8521S_SCR_SYNCE_ENABLE | YT8521S_SCR_CLK_SRC_MASK |
+			   YT8521S_SCR_CLK_FRE_SEL_125M;
+		val = YT8521S_SCR_SYNCE_ENABLE | YT8521S_SCR_CLK_FRE_SEL_125M |
+			  FIELD_PREP(YT8521S_SCR_CLK_SRC_MASK,
+				     YT8521S_SCR_CLK_SRC_PLL_125M);
+		break;
+	default:
+		pr_warn("Freq err:%u\n", priv->clk_out_frequency);
+		return -EINVAL;
+	}
+
+	ret = ytphy_modify_ext(phydev, YTPHY_SYNCE_CFG_REG, mask,
+			       val);
+	if (ret < 0)
+		return ret;
+
+	ret = ytphy_rgmii_clk_delay_config(phydev);
+	if (ret < 0)
+		return ret;
+
+	if (priv->flag & AUTO_SLEEP_DISABLED) {
+		/* disable auto sleep */
+		ret = ytphy_modify_ext(phydev,
+				       YT8531_EXTREG_SLEEP_CONTROL1_REG,
+				       YT8531_ESC1R_SLEEP_SW, 0);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (priv->flag & KEEP_PLL_ENABLED) {
+		/* enable RXC clock when no wire plug */
+		ret = ytphy_modify_ext(phydev,
+				       YT8531_CLOCK_GATING_REG,
+				       YT8531_CGR_RX_CLK_EN, 0);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int yt8531s_config(struct phy_device *phydev)
 {
 	struct ytphy_plat_priv *priv = phydev->priv;
@@ -1238,3 +1315,14 @@ U_BOOT_PHY_DRIVER(motorcomm8531S) = {
 	.startup	= &yt8531s_startup,
 	.shutdown	= &genphy_shutdown,
 };
+
+U_BOOT_PHY_DRIVER(motorcomm8521S) = {
+	.name		= "YT8521S Gigabit Ethernet Transceiver",
+	.uid		= PHY_ID_YT8521S,
+	.mask		= PHY_ID_MASK,
+	.features	= PHY_GBIT_FEATURES,
+	.probe		= &yt8531_probe,
+	.config		= &yt8521s_config,
+	.startup	= &yt8531s_startup,
+	.shutdown	= &genphy_shutdown,
+};
